require('dotenv').config();

const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const crypto = require('crypto');

const app = express();
const server = http.createServer(app);

const wss = new WebSocket.Server({ server });
const clients = new Set();


wss.on('connection', (ws) => {
  console.log('New WebSocket client connected');
  clients.add(ws);

  ws.on('close', () => {
    console.log('WebSocket client disconnected');
    clients.delete(ws);
  });
});

app.use(express.raw({   
    type: 'application/json'
})) 

const setupHooks = (secret) => {
	app.use('/webhook', express.json({
		verify: (req, res, buf) => {
			if (process.env.NODE_ENV !== "production") return;
    	
			const messageId = req.header('Twitch-Eventsub-Message-Id');
    		const timestamp = req.header('Twitch-Eventsub-Message-Timestamp');
    		const signature = req.header('Twitch-Eventsub-Message-Signature');
	    	const hmacMessage = messageId + timestamp + buf;
    		const expectedSignature = 'sha256=' + crypto.createHmac('sha256', secret)
        	                                       .update(hmacMessage)
            	                                   .digest('hex');
			if (signature !== expectedSignature) {
    			throw new Error('Invalid Twitch webhook signature');
    		}
	  	}
	}));

	app.post('/webhook/follower', (req, res) => {
 		const messageType = req.header('Twitch-Eventsub-Message-Type');
  		const message = req.body;
        if (messageType === 'webhook_callback_verification') 
			return res.status(200).send(message.challenge);
                
  		if (messageType === 'notification') {
	    	const eventType = message.subscription.type;
    		const eventData = message.event;
	    	const messageToSend = JSON.stringify({ type: eventType, data: eventData });
    		clients.forEach((client) => {
      			if (client.readyState !== WebSocket.OPEN) return;
        			
				client.send(messageToSend);
    		});
	 	} 
        
	 	res.status(204).end(); 
	});
}

async function readAndPrintStream(readableStream) {
  const reader = readableStream.getReader();
  const decoder = new TextDecoder(); // Create a TextDecoder
  let done = false;

  while (!done) {
    const { value, done: readerDone } = await reader.read();
    done = readerDone;

    if (value) {
          const textChunk = decoder.decode(value, { stream: true }); // Decode Uint8Array to text
      console.log(textChunk); 
	}
  }

  console.log('Stream reading complete.');
}

const init = async () => {
	const secret = crypto.randomBytes(32).toString('hex'); 
	
	const tokenRes = await fetch('https://id.twitch.tv/oauth2/token', {
		method: "POST",
		body: {
			client_id: process.env.CLIENT_ID,
			client_secret: process.env.CLIENT_SECRET,
			grant_type: "client_credentials"
		}
	})

	await readAndPrintStream(tokenRes.body)

	const response = await fetch('https://api.twitch.tv/helix/eventsub/subscriptions', {
    	method: "POST",
	  	headers: {
			"Content-Type": "application/json",
			"Client-Id": process.env.CLIENT_ID,	
  		},
		body: JSON.stringify({
			type: "channel.follow",
			version: 2,
			condition: {
				broadCaster_user_id: process.env.BROADCASTER_USER_ID,
				moderator_user_id: process.env.BROADCASTER_USER_ID
			},
			transport: {
        		method: 'webhook',
        		callback: `${process.env.MAIN_URL}/follower`,
        		secret
      		}
    	})
  	});

	readAndPrintStream(response.body)

	setupHooks(secret)

	const PORT = process.env.PORT || 3000;
	server.listen(PORT, () => {
  		console.log(`Server listening on port ${PORT}`);
	});
}

init()
